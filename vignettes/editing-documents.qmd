---
title: "Modifying Rmd and Quarto Documents"
format: html
vignette: >
  %\VignetteIndexEntry{Modifying Rmd and Quarto Documents}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(parsermd)
```

# Introduction

While parsing and selecting content from R Markdown and Quarto documents is powerful, the true potential of `parsermd` is realized when you start programmatically modifying those documents. This vignette covers the core functions for editing `rmd_ast` objects: `rmd_modify`, `rmd_insert`, and `rmd_fenced_div_wrap`.

These tools allow you to perform a wide range of tasks, such as:

-   Updating chunk options across an entire document.
-   Inserting boilerplate content into specific sections.
-   Wrapping existing content with new structural elements, like callout blocks.
-   Refactoring and reorganizing documents automatically.

Let's start with a sample document that we'll modify throughout this vignette.

```{r show-assignment}
# Load a sample document
doc_path = system.file("examples/hw02-complex.Rmd", package = "parsermd")
cat(readLines(doc_path), sep = "\n")
```

Now, let's parse it into an `rmd_ast` object.

```{r parse-document}
# Parse the assignment
rmd <- parse_rmd(doc_path)
rmd
```

---

# Modifying Nodes with `rmd_modify()`

The `rmd_modify()` function is your primary tool for changing the properties of existing nodes in the AST. It works by applying a function to all nodes that match a specific selector.

The syntax is `rmd_modify(ast, .f, .selection = everything())`, where:

-   `ast` is the `rmd_ast` object.
-   `.f` is a function that takes a node as input and returns the modified node.
-   `.selection` is a tidyselect expression to choose which nodes to modify.

## Example: Changing Chunk Options

Imagine you want to ensure all code chunks in your document are evaluated. You can use `rmd_modify()` to set the `eval` option to `TRUE` for all `rmd_chunk` nodes.

```{r modify-chunk-options}
# Set eval = TRUE for all R chunks
modified_rmd <- rmd |>
  rmd_modify(
    # The function to apply to each selected node
    .f = function(node) {
      rmd_node_options(node)$eval <- TRUE
      node # Return the modified node
    },
    # The selection criteria
    .selection = has_type("rmd_chunk") & has_engine("r")
  )

# Let's inspect the options of the first chunk
rmd_select(modified_rmd, has_label("data-prep")) |>
  as_tibble()
```

Notice how the `eval` option, which was previously `FALSE`, is now `TRUE`.

## Example: Modifying Text Content

Beyond changing metadata like chunk options, `rmd_modify()` can also be used to alter the content of nodes. For example, you could perform a search-and-replace operation on all markdown text in a specific section.

Let's replace the word "data" with "dataset" in the "Data Munging" section of our document.

```{r modify-text-content}
# Create a function to replace text in markdown nodes
replace_word_in_markdown <- function(node) {
  # Only act on markdown nodes
  if (inherits(node, "rmd_markdown")) {
    # Access the lines and modify them
    node@lines <- gsub("data", "dataset", node@lines, ignore.case = TRUE)
  }
  # Return the (potentially modified) node
  node
}

# Apply this function to the "Data Munging" section
content_modified_rmd <- rmd |>
  rmd_modify(
    .f = replace_word_in_markdown,
    .selection = by_section("Data Munging")
  )

# Let's see the modified text
content_modified_rmd |>
  rmd_select(by_section("Data Munging")) |>
  as_document() |>
  cat()
```

This example shows how you can define a function that operates on the `@lines` property of a markdown node to programmatically change the document's text.

---

# Inserting Nodes with `rmd_insert()`

To add new content to a document, you can use `rmd_insert()`. This function allows you to insert one or more `rmd_node` objects before or after a selected location.

The syntax is `rmd_insert(ast, ..., .before = NULL, .after = NULL)`, where:

-   `ast` is the `rmd_ast` object.
-   `...` are the `rmd_node` objects to insert.
-   `.before` or `.after` is a tidyselect expression specifying the insertion point. You can only use one of them.

## Example: Adding a Setup Chunk

A common task is to add a setup chunk at the beginning of a document (right after the YAML front matter). Let's create a setup chunk and insert it.

```{r create-setup-chunk}
# Create a new setup chunk
setup_chunk <- rmd_chunk(
  name = "setup",
  code = "knitr::opts_chunk$set(echo = TRUE)",
  options = list(include = FALSE)
)

setup_chunk
```

Now, let's insert it after the YAML header.

```{r insert-setup-chunk}
# Insert the new chunk after the YAML node
inserted_rmd <- rmd |>
  rmd_insert(
    setup_chunk,
    .after = has_type("rmd_yaml")
  )

# Print the top of the document to see the new chunk
print(inserted_rmd)
```

The `setup` chunk has been successfully added to the AST.

---

# Working with Structural Elements

Tools like Quarto have introduced powerful structural elements like Fenced Divs (`:::`) and Shortcodes (`{{< ... >}}`) for creating complex layouts and embedding content. `parsermd` provides functions to both create and interact with these elements.

## Wrapping Nodes in Fenced Divs

The `rmd_fenced_div_wrap()` function makes it easy to wrap existing nodes in a new fenced div, which is useful for creating things like callout blocks or columns.

Let's wrap the "Important Note" section of our document in a "warning" callout block to make it more prominent.

```{r wrap-in-callout}
# Wrap the selected section in a warning callout
wrapped_rmd <- rmd |>
  rmd_fenced_div_wrap(
    .selection = by_section("Important Note"),
    .classes = "callout-warning",
    .id = "note-callout"
  )

# Let's view the new structure as a document
cat(as_document(wrapped_rmd))
```

## Selecting Content Inside Fenced Divs

Once you have fenced divs in your document, you might want to select the content *inside* them. You can do this with the `by_fdiv()` selection helper.

Let's use the document we just created and select the content inside the callout.

```{r}
# Select all nodes inside the .callout-warning div
tip_content <- rmd_select(
  wrapped_rmd,
  by_fdiv(has_class("callout-warning"))
)

tip_content
```

The `by_fdiv()` helper is very powerful. It takes another selection expression as its argument, allowing you to find divs based on their ID, classes, or attributes, and then selects all the nodes contained within that div.

## Working with Shortcodes

Shortcodes (`{{< ... >}}`) are another powerful way to embed complex or dynamic content in R Markdown and Quarto documents. `parsermd` allows you to find and even modify these shortcodes.

### Extracting Shortcodes

Let's imagine we have a document that uses shortcodes to embed videos.

```{r}
qmd_text <- c(
  "---",
  "title: My Video Collection",
  "---",
  "",
  "# Introduction",
  "",
  "Here is my first video:",
  "{{< video https://example.com/video1.mp4 >}}",
  "",
  "And here is another one with more options:",
  "{{< video https://example.com/video2.mp4 title=\"Second Video\" >}}",
  ""
)

# Parse the text
rmd_with_shortcodes <- parse_rmd(qmd_text)
```

Shortcodes are part of `rmd_markdown` nodes. To find them, we can use the `rmd_extract_shortcodes()` function on the content of a markdown node.

```{r}
# Select the markdown node containing the first shortcode
md_node <- rmd_select(rmd_with_shortcodes, has_type("rmd_markdown"))[[2]]

# Extract shortcodes from that node
(shortcodes <- rmd_extract_shortcodes(md_node))
```

The function returns a list of `rmd_shortcode` objects, giving you access to the function name and arguments.

### Modifying Shortcodes

Since shortcodes are part of the markdown text, modifying them involves changing the `lines` property of the containing `rmd_markdown` node.

Let's say we want to replace all `video` shortcodes with a placeholder message.

```{r}
# A function to modify a markdown node
replace_video_shortcodes <- function(node) {
  # Check if the node is markdown and contains a video shortcode
  if (inherits(node, "rmd_markdown") && rmd_has_shortcode(node, "video")) {
    node@lines <- stringr::str_replace(
      node@lines,
      "\\{\\{< video .* >\\}\\}",
      "[VIDEO PLACEHOLDER]"
    )
  }
  node
}

# Apply the modification to the whole document
modified_rmd_shortcodes <- rmd_modify(rmd_with_shortcodes, replace_video_shortcodes)

# See the result
cat(as_document(modified_rmd_shortcodes))
```

This demonstrates how you can use `rmd_modify` in combination with text manipulation functions to alter shortcodes.
